#ifndef G_LOG_DOMAIN
# define G_LOG_DOMAIN "sqliterepo"
#endif

#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>

#include <metautils/lib/metautils.h>
#include <metautils/lib/metacomm.h>

#include "sqliterepo.h"
#include "hash.h"
#include "election.h"
#include "version.h"
#include "sqlx_remote.h"
#include "synchro.h"
#include "internals.h"

#define EVENTLOG_SIZE 16
#define COND_COUNT 4096
#define STATUS_FINAL(e) ((e) & 0x10)

#define manager_get_member(M,K) lru_tree_get((M)->lrutree_members, (K))

typedef guint req_id_t;
typedef guint16 req_counter_t;

enum election_step_e
{
	STEP_NONE        = 0x00,
	STEP_CANDREQ     = 0x01,
	STEP_CANDOK      = 0x02,
	STEP_LEAVING     = 0x03,
	STEP_PRELOST     = 0x04,
	STEP_PRELEAD     = 0x05,

	STEP_LOST        = 0x10,
	STEP_LEADER      = 0x11,
	STEP_FAILED      = 0x12,
};

enum event_type_e
{
	EVT_NONE = 0,
	EVT_DISCONNECTED,
	EVT_EXITING,

	EVT_GETVERS_OK,
	EVT_GETVERS_OUTDATED,
	EVT_GETVERS_CONCURRENT,
	EVT_GETVERS_ERROR,

	EVT_USE_RES,

	EVT_CREATE_OK,
	EVT_CREATE_KO,

	EVT_NODE_LEFT,

	EVT_MASTER_KO,
	EVT_MASTER_EMPTY,
	EVT_MASTER_OK,
	EVT_MASTER_CHANGE,

	EVT_RESYNC_REQ,
	EVT_RESYNC_DONE,

	EVT_LIST_OK,
	EVT_LIST_KO,

	EVT_LEAVE_OK,
	EVT_LEAVE_KO,
};

struct logged_event_s
{
	enum event_type_e event   :8;
	enum election_step_e pre  :8;
	enum election_step_e post :8;
};

struct election_manager_s
{
	struct election_manager_vtable_s *vtable;

	struct sqlx_sync_s *sync;

	/* pool'ifies the client sockets to avoid reserving to many file
	 * descriptors. */
	struct gridd_client_pool_s *pool;

	/* do not free or change the fields below */
	const struct replication_config_s *config;

	struct lru_tree_s *lrutree_members; // pending elections
	GMutex *lock;
	GCond *conds[COND_COUNT];

	time_t delay_max_wait; /*!< how many seconds we accept to wait for a
							    status. */
	time_t delay_write_lock; /*!< how many seconds we may wait for a write
								  lock on an election member. */
	time_t delay_restart_failed; /*!< how many seconds we wait before
									  restarting a failed election. */
	time_t delay_max_idle; /*!< how many seconds we wait before deciding a
							    pending election is stalled. */

	time_t delay_ping_pending;
	time_t delay_ping_final;
	time_t delay_ping_failed;

	gboolean exiting;

	req_id_t next_id;
};

struct election_member_s
{
	struct election_manager_s *manager;
	hashstr_t *key;
	gchar *name;
	gchar *type;

	/* election status */
	GTimeVal last_status;

	gint64 myid; /*!< generated by zookeeper */

	gchar *master_url; /*!< First node of the children sequence */
	gint64 master_id; /* !< terminal ID of the master_url */

	struct logged_event_s log[EVENTLOG_SIZE];

	guint log_index;
	guint32 refcount;

	time_t last_USE;

	req_id_t reqid_USE;
	req_id_t reqid_PIPEFROM;
	req_id_t reqid_GETVERS;

	req_counter_t concurrent_GETVERS;
	req_counter_t errors_GETVERS;
	req_counter_t pending_GETVERS;
	req_counter_t sent_GETVERS;

	req_counter_t pending_USE;

	enum election_step_e step : 8;

	char requested_USE : 1;
	char requested_PIPEFROM : 1;
	char pending_PIPEFROM : 1;
};

/* ------------------------------------------------------------------------- */

static void member_destroy(struct election_member_s *member);

static void _manager_clean(struct election_manager_s *manager);

static const struct replication_config_s * _manager_get_config(
		const struct election_manager_s *manager);

static void _manager_exit_all(struct election_manager_s *manager, GTimeVal *max,
		gboolean persist);

static guint _manager_retry_elections(struct election_manager_s *manager,
		guint max, GTimeVal *end);

static GError * _election_trigger_RESYNC(struct election_manager_s *manager,
		const gchar *name, const gchar *type);
static GError * _election_init(struct election_manager_s *manager,
		const gchar *name, const gchar *type);
static GError * _election_start(struct election_manager_s *manager,
		const gchar *name, const gchar *type);
static GError * _election_exit(struct election_manager_s *manager,
		const gchar *name, const gchar *type);
static GError * _election_has_peers(struct election_manager_s *manager,
		const gchar *name, const gchar *type, gboolean *peers_present);
static GError * _election_get_peers(struct election_manager_s *manager,
		const gchar *name, const gchar *type, gchar ***peers);
static void _election_whatabout(struct election_manager_s *m,
		const gchar *name, const gchar *type, gchar *d, gsize ds);
static enum election_status_e _election_get_status(struct election_manager_s *m,
		const gchar *name, const gchar *type, gchar **master_url);
static struct election_counts_s _manager_count(struct election_manager_s *manager);

static struct election_manager_vtable_s VTABLE =
{
	_manager_clean,
	_manager_get_config,
	_manager_retry_elections,
	_manager_exit_all,
	_manager_count,
	_election_init,
	_election_start,
	_election_exit,
	_election_has_peers,
	_election_get_peers,
	_election_get_status,
	_election_trigger_RESYNC,
	_election_whatabout
};

static void transition_error(struct election_member_s *member,
		enum event_type_e evt, enum ZOO_ERRORS zrc);

static void transition(struct election_member_s *member,
		enum event_type_e evt_type, void *evt_arg);

static void defer_PIPEFROM(struct election_member_s *member);

static gboolean defer_USE(struct election_member_s *member, time_t now);

static void defer_GETVERS(struct election_member_s *member);

static void member_debug(const gchar *func, const gchar *tag,
		const struct election_member_s *m);

/* Public specific API ----------------------------------------------------- */

GError *
election_manager_create(struct replication_config_s *config,
		struct election_manager_s **result)
{
	struct election_manager_s *manager;

	EXTRA_ASSERT(result != NULL);
	EXTRA_ASSERT(config != NULL);

	*result = NULL;
	if (NULL == config->get_local_url || NULL == config->get_peers
		|| NULL == config->get_version || ELECTION_MODE_GROUP < config->mode)
		return NEWERROR(ERRCODE_PARAM, "Invalid configuration");

	manager = g_malloc0(sizeof(*manager));
	manager->vtable = &VTABLE;
	manager->delay_write_lock = 5;
	manager->delay_restart_failed = 2;
	manager->delay_max_idle = 30;
	manager->delay_max_wait = 5;
	manager->delay_ping_failed = 2;
	manager->delay_ping_pending = 2;
	manager->delay_ping_final = 300;

	manager->config = config;

	manager->lrutree_members = lru_tree_create(
			(GCompareFunc)hashstr_quick_cmp,
			g_free, (GDestroyNotify)member_destroy, 0);

	manager->lock = g_mutex_new();
	for (guint i=0; i<COND_COUNT ;i++)
		manager->conds[i] = g_cond_new();

	*result = manager;
	return NULL;
}

void
election_manager_set_clients(struct election_manager_s *manager,
		struct gridd_client_pool_s *pool)
{
	EXTRA_ASSERT(manager != NULL);
	EXTRA_ASSERT(pool != NULL);
	EXTRA_ASSERT(manager->vtable == &VTABLE);
	manager->pool = pool;
}

void
election_manager_set_sync (struct election_manager_s *manager,
		struct sqlx_sync_s *my_sync)
{
	EXTRA_ASSERT(manager != NULL);
	EXTRA_ASSERT(my_sync != NULL);
	EXTRA_ASSERT(manager->vtable == &VTABLE);
	manager->sync = my_sync;
}

/* XXX MIsc helpers -------------------------------------------------------- */

static gdouble
time2double(time_t t)
{
	gdouble d = t;
	return d;
}

static inline void
gtv_init_ago(GTimeVal *ago, time_t delay)
{
	glong d;

	d = delay;
	d = d * -1000000L;
	g_get_current_time(ago);
	g_time_val_add(ago, d);
}

static GArray *
nodev_to_int64v(const struct String_vector *sv, const gchar *prefix)
{
	const gchar *stripe, *s;
	GArray *array;
	int32_t i, max;

	array = g_array_new(0, 0, sizeof(gint64));

	for (i=0,max=sv->count; i<max ;i++) {
		s = sv->data[i];
		if (g_str_has_prefix(s, prefix)) {
			if (NULL != (stripe = strrchr(s,'-'))) {
				gint64 i64 = g_ascii_strtoll(stripe+1, NULL, 10);
				g_array_append_vals(array, &i64, 1);
			}
		}
	}

	if (array->len > 1)
		g_array_sort(array, gint64_sort);

	return array;
}

static const gchar *
_step2str(enum election_step_e step)
{
	switch (step) {
		case STEP_NONE:
			return "NONE";
		case STEP_CANDREQ:
			return "CANDREQ";
		case STEP_CANDOK:
			return "CANDOK";
		case STEP_LEAVING:
			return "LEAVING";
		case STEP_PRELOST:
			return "PRELOST";
		case STEP_PRELEAD:
			return "PRELEAD";
		case STEP_LOST:
			return "LOST";
		case STEP_LEADER:
			return "LEADER";
		case STEP_FAILED:
			return "FAILED";
	}
	return "!INVALID!";
}

static const gchar *
_evt2str(enum event_type_e evt)
{
	switch (evt) {
		case EVT_NONE:
			return "NONE";
		case EVT_DISCONNECTED:
			return "DISCO";
		case EVT_EXITING:
			return "EXIT";
		case EVT_USE_RES:
			return "USE";

		case EVT_GETVERS_OK:
			return "VER_OK";
		case EVT_GETVERS_OUTDATED:
			return "VER_OUT";
		case EVT_GETVERS_CONCURRENT:
			return "VER_CONC";
		case EVT_GETVERS_ERROR:
			return "VER_ERR";

		case EVT_CREATE_OK:
			return "CREATE_OK";
		case EVT_CREATE_KO:
			return "CREATE_KO";
		case EVT_NODE_LEFT:
			return "NODE_LEFT";
		case EVT_MASTER_KO:
			return "MASTER_KO";
		case EVT_MASTER_EMPTY:
			return "MASTER_EMPTY";
		case EVT_MASTER_OK:
			return "MASTER_OK";
		case EVT_MASTER_CHANGE:
			return "MASTER_CHANGE";
		case EVT_RESYNC_REQ:
			return "RESYNC_REQ";
		case EVT_RESYNC_DONE:
			return "RESYNC_DONE";
		case EVT_LIST_OK:
			return "LIST_OK";
		case EVT_LIST_KO:
			return "LIST_KO";
		case EVT_LEAVE_OK:
			return "LEAVE_OK";
		case EVT_LEAVE_KO:
			return "LEAVE_KO";
	}

	return "!INVALID!";
}

/* XXX Member handling ----------------------------------------------------- */


static inline req_id_t
manager_next_reqid(struct election_manager_s *m)
{
	return ++ m->next_id;
}

static inline gboolean
member_has_action(struct election_member_s *m)
{
	return m->pending_GETVERS || m->pending_PIPEFROM || m->requested_PIPEFROM;
}

static inline const gchar*
member_get_url(struct election_member_s *m)
{
	return sqlx_config_get_local_url(MCFG(m));
}

static GError *
member_get_peers(struct election_member_s *m, gchar ***peers)
{
	return sqlx_config_get_peers(MCFG(m), m->name, m->type, peers);
}

static inline void
member_kickoff(struct election_member_s *m)
{
	transition(m, EVT_NONE, NULL);
}

static inline void
member_ref(struct election_member_s *m)
{
	++ m->refcount;
}

static inline void
member_unref(struct election_member_s *m)
{
	-- m->refcount;
}

static inline GCond*
member_get_cond(struct election_member_s *m)
{
	register guint h = hashstr_hash(m->key);
	return MMANAGER(m)->conds[h % COND_COUNT];
}

static inline GMutex*
member_get_lock(struct election_member_s *m)
{
	return MMANAGER(m)->lock;
}

static inline void
member_lock(struct election_member_s *m)
{
	g_mutex_lock(member_get_lock(m));
}

static inline void
member_unlock(struct election_member_s *m)
{
	g_mutex_unlock(member_get_lock(m));
}

static inline void
member_signal(struct election_member_s *m)
{
	g_cond_signal(member_get_cond(m));
}

static inline gboolean
member_wait(struct election_member_s *m, GTimeVal *max)
{
	return g_cond_timed_wait(member_get_cond(m), member_get_lock(m), max);
}

static inline void
member_set_master_url(struct election_member_s *m, const gchar *u)
{
	metautils_str_replace(&(m->master_url), u);
	if (u)
		member_debug(__FUNCTION__, "MASTER_URL", m);
}

static inline void
member_reset_master(struct election_member_s *m)
{
	m->master_id = -1;
	member_set_master_url(m, NULL);
}

static inline void
member_reset_pending(struct election_member_s *m)
{
	m->sent_GETVERS = 0;
	m->concurrent_GETVERS = 0;
	m->errors_GETVERS = 0;
	m->reqid_GETVERS = 0;
	m->reqid_PIPEFROM = 0;
	m->pending_GETVERS = 0;
	m->pending_PIPEFROM = 0;
}

static inline void
member_reset(struct election_member_s *m)
{
	member_reset_master(m);
	member_reset_pending(m);
	m->myid = -1;
}

static inline void
member_set_id(struct election_member_s *m, gint64 id)
{
	EXTRA_ASSERT(id >= 0);
	EXTRA_ASSERT(m->myid <= 0);
	m->myid = id;
	member_debug(__FUNCTION__, "ID", m);
}

static inline void
member_set_status(struct election_member_s *m, enum election_step_e s)
{
	g_get_current_time(&(m->last_status));
	m->step = s;
	if (STATUS_FINAL(s)) {
		member_debug(__FUNCTION__, "FINAL", m);
		member_signal(m);
	}
	else if (s == STEP_NONE) {
		member_signal(m);
	}
}

static inline void
member_set_master_id(struct election_member_s *m, gint64 i64)
{
	EXTRA_ASSERT(i64 >= 0);
	if (i64 != m->master_id)
		member_set_master_url(m, NULL);
	m->master_id = i64;
	member_debug(__FUNCTION__, "MASTER_ID", m);
}

static void
member_log_event(struct election_member_s *member, enum election_step_e pre,
		enum event_type_e evt)
{
	struct logged_event_s *plog;
	plog = member->log + ((member->log_index++) % EVENTLOG_SIZE);
	plog->event = evt;
	plog->pre = pre;
	plog->post = member->step;
}

static gchar*
member_dump_log(struct election_member_s *member)
{
	GString *out= g_string_new("\n\tP: ");

	/* local url */
	g_string_append(out, member_get_url(member));

	/* the peers */
	gchar **peers = NULL;
	GError *err = member_get_peers(member, &peers);
	if (err != NULL) {
		g_string_append_printf(out, "NOT MANAGED (%d) %s",
				err->code, err->message);
		g_clear_error(&err);
	}
	else if (peers) {
		for (gchar **p = peers; *p ;p++) {
			g_string_append_c(out, '|');
			g_string_append(out, *p);
		}
		g_strfreev(peers);
	}

	/* then the livelog */
	guint idx = member->log_index - 1;
	for (guint i=0; i<EVENTLOG_SIZE ;i++,idx--) {
		struct logged_event_s *plog = member->log + (idx % EVENTLOG_SIZE);
		if (!plog->pre && !plog->post)
			break;
		g_string_append_printf(out, "\n\t%s:%s:%s",
				_step2str(plog->pre),
				_evt2str(plog->event),
				_step2str(plog->post));
	}

	return g_string_free(out, FALSE);
}

static void
member_descr(const struct election_member_s *m, gchar *d, gsize ds)
{
	g_snprintf(d, ds,
			"%s [%"G_GINT64_FORMAT"/%"G_GINT64_FORMAT"/%s] %u/%u/%u/%u [%.*s] [%s.%s]",
			_step2str(m->step), m->myid, m->master_id, m->master_url,
			m->refcount, m->pending_USE, m->pending_GETVERS, m->pending_PIPEFROM,
			hashstr_ulen(m->key), hashstr_str(m->key),
			m->name, m->type);
}

static void
member_trace(const gchar *func, const gchar *tag,
		const struct election_member_s *m)
{
	(void) func;
	(void) tag;
	(void) m;
#ifdef HAVE_EXTRA_DEBUG
	gchar d[256];
	if (!GRID_TRACE2_ENABLED())
		return;
	member_descr(m, d, sizeof(d));
	GRID_TRACE2("%s %s %s", tag ? tag : "", d, func ? func : "");
#endif
}

static void
member_debug(const gchar *func, const gchar *tag,
		const struct election_member_s *m)
{
	gchar d[256];
	member_descr(m, d, sizeof(d));
	GRID_DEBUG("%s %s %s", tag ? tag : "", d, func ? func : "");
}

static void
member_warn(const gchar *tag, const struct election_member_s *m)
{
	gchar d[256];
	member_descr(m, d, sizeof(d));
	GRID_WARN("%s %s", tag ? tag : "", d);
}


static struct election_member_s *
member_create(struct election_manager_s *manager,
		const gchar *name, const gchar *type,
		const struct hashstr_s *key)
{
	GTimeVal now;
	struct election_member_s *result;

	g_get_current_time(&now);
	MANAGER_CHECK(manager);

	result = g_malloc0(sizeof(*result));
	result->manager = manager;
	memcpy(&(result->last_status), &now, sizeof(now));
	result->key = hashstr_dup(key);
	result->name = g_strdup(name);
	result->type = g_strdup(type);
	result->myid = result->master_id = -1;

	return result;
}

static gchar *
member_fullpath(struct election_member_s *member)
{
	return (member->myid >= 0)
		? g_strdup_printf("%s-%010"G_GINT64_FORMAT,
				hashstr_str(member->key), member->myid)
		: g_strdup_printf("%s-",
				hashstr_str(member->key));
}

static gchar *
member_masterpath(struct election_member_s *member)
{
	return (member->master_id < 0) ? NULL
		: g_strdup_printf("%s-%010"G_GINT64_FORMAT,
				hashstr_str(member->key), member->master_id);
}

static void
member_destroy(struct election_member_s *member)
{
	if (!member)
		return;

	if (member->master_url)
		g_free(member->master_url);
	if (member->key)
		g_free(member->key);
	if (member->name)
		g_free(member->name);
	if (member->type)
		g_free(member->type);

	memset(member, 0, sizeof(*member));
	member->myid = member->master_id = -1;
	g_free(member);
}

static gboolean
member_group_master(struct election_member_s *member, GArray *i64v)
{
	EXTRA_ASSERT(i64v != NULL);
	EXTRA_ASSERT(i64v->len > 0);
	if (member->myid < 0)
		return FALSE;
	return g_array_index(i64v, gint64, 0) == member->myid;
}

static gboolean
member_in_group(struct election_member_s *member, GArray *i64v)
{
	guint i;
	gint64 i64;

	EXTRA_ASSERT(i64v != NULL);
	if (member->myid < 0)
		return FALSE;
	for (i=0; i<i64v->len ;i++) {
		i64 = g_array_index(i64v, gint64, i);
		if (i64 == member->myid)
			return TRUE;
	}
	return FALSE;
}

static gboolean
member_pending_for_too_long(struct election_member_s *member)
{
	GTimeVal ago;

	switch (member->step) {
		case STEP_NONE:
			return FALSE;
		case STEP_CANDREQ:
		case STEP_CANDOK:
		case STEP_PRELOST:
		case STEP_PRELEAD:
			gtv_init_ago(&ago, member->manager->delay_max_idle);
			return gtv_bigger(&ago, &(member->last_status));
		case STEP_LEAVING:
		case STEP_LEADER:
		case STEP_LOST:
		case STEP_FAILED:
			return FALSE;
	}

	g_assert_not_reached();
	return FALSE;
}

static gboolean
member_failed_for_too_long(struct election_member_s *member)
{
	GTimeVal ago;

	if (member->step != STEP_FAILED)
		return FALSE;
	gtv_init_ago(&ago, member->manager->delay_restart_failed);
	return gtv_bigger(&ago, &(member->last_status));
}

static struct election_member_s *
manager_init_member(struct election_manager_s *manager,
		const gchar *name, const gchar *type, gboolean lazy)
{
	struct election_member_s *member;
	struct hashstr_s *key;

	MANAGER_CHECK(manager);

	key = sqliterepo_hash_name(name, type);
	member = manager_get_member(manager, key);
	if (!member && lazy) {
		member = member_create(manager, name, type, key);
		lru_tree_insert(manager->lrutree_members, hashstr_dup(key), member);
	}
	g_free(key);
	if (member)
		member_ref(member);
	return member;
}

static guint
manager_count_active(struct election_manager_s *manager)
{
	guint count;
	gboolean _count(gpointer k, gpointer v, gpointer u) {
		enum election_step_e step;
		(void) k; (void) u;
		MEMBER_CHECK(v);
		step = MEMBER(v)->step;
		if (step != STEP_NONE && step != STEP_FAILED)
			++ count;
		return FALSE;
	}

	count = 0;
	g_mutex_lock(manager->lock);
	lru_tree_foreach_TREE(manager->lrutree_members, _count, NULL);
	g_mutex_unlock(manager->lock);
	return count;
}

static void
manager_send_EXITING(struct election_manager_s *manager)
{
	gboolean send_exit(gpointer k, gpointer v, gpointer u) {
		(void) k; (void) u;
		MEMBER_CHECK(v);
		if (MEMBER(v)->step != STEP_NONE)
			transition(v, EVT_EXITING, NULL);
		return FALSE;
	}

	lru_tree_foreach_TREE(manager->lrutree_members, send_exit, NULL);
	GRID_INFO("EXIT order sent");
}

static void
_manager_exit_all(struct election_manager_s *manager, GTimeVal *max,
		gboolean persist)
{
	GTimeVal now;
	guint count;

	GRID_INFO("Voluntarily exiting all the elections...");
	MANAGER_CHECK(manager);

	/* Order the node to exit */
	g_mutex_lock(manager->lock);
	manager->exiting = TRUE;
	manager_send_EXITING(manager);
	g_mutex_unlock(manager->lock);

	while (0 < (count = manager_count_active(manager))) {
		GRID_INFO("Waiting for %u active elections", count);
		g_get_current_time(&now);
		if (max && gtv_bigger(&now, max)) {
			GRID_WARN("TIMEOUT while waiting for active elections");
			return;
		}
		usleep(500000);
	}
	if ( ! persist ) {
		manager->exiting = FALSE;
	}

	GRID_INFO("No more active elections");
}

static void
_election_whatabout(struct election_manager_s *m,
		const gchar *name, const gchar *type, gchar *d, gsize ds)
{
	struct election_member_s *member;
	hashstr_t *key;

	MANAGER_CHECK(m);
	EXTRA_ASSERT(name != NULL);
	EXTRA_ASSERT(type != NULL);
	EXTRA_ASSERT(d != NULL);
	EXTRA_ASSERT(ds > 0);

	key = sqliterepo_hash_name(name, type);
	g_mutex_lock(m->lock);
	member = manager_get_member(m, key);
	if (member) {
		gchar *log;

		member_descr(member, d, ds);
		log = member_dump_log(member);
		g_strlcat(d, log, ds);
		g_free(log);
	}
	else
		g_snprintf(d, ds, "Not found");
	g_mutex_unlock(m->lock);

	g_free(key);
}

/* XXX Zookeeper callbacks ------------------------------------------------- */

static void
step_AskMaster_completion(int zrc, const char *v, int vlen,
		const struct Stat *s, const void *d)
{
	gchar *master = NULL;
	struct election_member_s *member;

	(void) s;
	member = (struct election_member_s *)d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	master = (v && vlen && *v) ? g_strndup(v, vlen) : NULL;

	member_lock(member);
	if (zrc != ZOK) {
		transition_error(member, EVT_MASTER_KO, zrc);
	}
	else {
		if (!master) {
			transition(member, EVT_MASTER_EMPTY, &zrc);
		}
		else {
			transition(member, EVT_MASTER_OK, master);
		}
	}
	member_unref(member);
	member_unlock(member);

	if (master)
		g_free(master);
}

static void
step_ListGroup_completion(int zrc, const struct String_vector *sv,
		const void *data)
{
	struct election_member_s *member;

	member = (struct election_member_s *) data;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);

	if (zrc != ZOK) {
		transition_error(member, EVT_LIST_KO, zrc);
	}
	else {
		GArray *i64v = nodev_to_int64v(sv, hashstr_str(member->key));
		transition(member, EVT_LIST_OK, i64v);
		g_array_free(i64v, TRUE);
	}

	member_unref(member);
	member_unlock(member);
}

static void
step_LeaveElection_completion(int zrc, const void *d)
{
	struct election_member_s *member;

	member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);
	if (zrc != ZOK) {
		if (zrc == ZNONODE) {
			transition(member, EVT_LEAVE_OK, NULL);
		}
		else {
			transition_error(member, EVT_LEAVE_KO, zrc);
		}
	}
	else {
		transition(member, EVT_LEAVE_OK, NULL);
	}
	member_unref(member);
	member_unlock(member);
}

static void
step_WatchNode_completion(int zrc, const struct Stat *s, const void *d)
{
	struct election_member_s *member;

	(void) s;

	member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);
	if (zrc != ZOK) {
		if (zrc == ZNONODE) {
			transition(member, EVT_NODE_LEFT, &zrc);
		}
		else {
			transition_error(member, EVT_NONE, zrc);
		}
	}
	member_unref(member);
	member_unlock(member);
}

static void
step_StartElection_completion(int zrc, const char *path, const void *d)
{
	gint64 i64;
	struct election_member_s *member;

	member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);
	if (zrc != ZOK) {
		transition_error(member, EVT_CREATE_KO, zrc);
	}
	else {
		if (!path) {
			transition(member, EVT_CREATE_KO, &zrc);
		}
		else {
			i64 = g_ascii_strtoll(strrchr(path, '-')+1, NULL, 10);
			transition(member, EVT_CREATE_OK, &i64);
		}
	}
	member_unref(member);
	member_unlock(member);
}

/* XXX Zookeeper monitors -------------------------------------------------- */

static void
step_WatchMaster_change(zhandle_t *handle, int type, int state,
			const char *path, void *d)
{
	struct election_member_s *member;

	(void) handle;
	(void) type;
	(void) state;
	(void) path;

	member = d;
	member_trace(__FUNCTION__, "CHANGE", member);
	MEMBER_CHECK(member);

	member_lock(member);
	transition(member, EVT_MASTER_CHANGE, NULL);
	member_unref(member);
	member_unlock(member);
}

static void
step_WatchNode_change(zhandle_t *handle, int type, int state,
		const char *path, void *d)
{
	struct election_member_s *member;

	(void) handle;
	(void) type;
	(void) state;
	(void) path;

	member = d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "CHANGE", member);

	member_lock(member);
	transition(member, EVT_NODE_LEFT, NULL);
	member_unref(member);
	member_unlock(member);
}

/* ------------------------------------------------------------------------- */

static void
member_warn_failed_creation(struct election_member_s *member, int zrc)
{
	gchar *p = member_fullpath(member);
	GRID_WARN("CREATE failed [%s.%s] [%s] : (%d) %s",
			member->name, member->type, p, zrc, zerror(zrc));
	g_free(p);
}

static int
step_StartElection_start(struct election_member_s *member)
{
	const gchar *myurl;
	gchar *path;
	int zrc;

	member_trace(__FUNCTION__, "ACTION", member);

	myurl = member_get_url(member);
	path = member_fullpath(member);
	zrc = sqlx_sync_acreate(member->manager->sync,
			path, myurl, strlen(myurl),
			ZOO_EPHEMERAL|ZOO_SEQUENCE,
			step_StartElection_completion, member);
	g_free(path);

	if (zrc == ZOK) {
		member_ref(member);
	}
	return zrc;
}

static int
step_AskMaster_start(struct election_member_s *member)
{
	int zrc = ZNONODE;
	gchar *path = NULL;

	member_trace(__FUNCTION__, "ACTION", member);

	if (NULL != (path = member_masterpath(member))) {
		zrc = sqlx_sync_awget(member->manager->sync, path,
				step_WatchMaster_change, member,
				step_AskMaster_completion, member);
		g_free(path);
		if (zrc == ZOK) {
			member_ref(member);
			member_ref(member);
		}
	}

	return zrc;
}

static int
step_WatchNode_start(struct election_member_s *member)
{
	int zrc = ZNONODE;
	gchar *path = NULL;

	member_trace(__FUNCTION__, "ACTION", member);

	if (NULL != (path = member_fullpath(member))) {
		zrc = sqlx_sync_awexists(member->manager->sync, path,
				step_WatchNode_change, member,
				step_WatchNode_completion, member);
		g_free(path);
		if (zrc == ZOK) {
			member_ref(member);
			member_ref(member);
		}
	}

	return zrc;
}

static int
step_ListGroup_start(struct election_member_s *member)
{
	int zrc;
	gchar *path;

	member_trace(__FUNCTION__, "ACTION", member);

	path = member_fullpath(member);
	zrc = sqlx_sync_awget_siblings(member->manager->sync, path,
			NULL, NULL,
			step_ListGroup_completion, member);
	g_free(path);

	if (zrc == ZOK) {
		member_ref(member);
	}

	return zrc;
}

static int
step_LeaveElection_start(struct election_member_s *member)
{
	int zrc;
	gchar *path;

	member_trace(__FUNCTION__, "ACTION", member);

	path = member_fullpath(member);
	zrc = sqlx_sync_adelete(member->manager->sync, path, -1,
			step_LeaveElection_completion, member);
	g_free(path);

	if (zrc == ZOK)
		member_ref(member);
	return zrc;
}


/* ------------------------------------------------------------------------- */


enum election_op_e {
	ELOP_NONE, ELOP_START, ELOP_RESYNC, ELOP_EXIT
};

static GError *
_election_make(struct election_manager_s *m, const gchar *name,
		const gchar *type, enum election_op_e op)
{
	MANAGER_CHECK(m);
	EXTRA_ASSERT(name != NULL);
	EXTRA_ASSERT(type != NULL);

	gboolean peers_present = FALSE;
	GError *err = election_has_peers(m, name, type, &peers_present);
	if (err != NULL) {
		g_prefix_error(&err, "Election error: ");
		return err;
	}
	if (!peers_present) {
		GRID_DEBUG("No peer for [%s][%s]", name, type);
		return NULL;
	}

	g_mutex_lock(m->lock);
	struct election_member_s *member = manager_init_member(m, name, type,
			op != ELOP_EXIT);
	switch (op) {
		case ELOP_NONE:
			break;
		case ELOP_START:
			transition(member, EVT_NONE, NULL);
			break;
		case ELOP_RESYNC:
			transition(member, EVT_RESYNC_REQ, NULL);
			break;
		case ELOP_EXIT:
			if (member)
				transition(member, EVT_EXITING, NULL);
			break;
	}
	if (member)
		member_unref(member);
	g_mutex_unlock(m->lock);

	return NULL;
}

static GError *
_election_trigger_RESYNC(struct election_manager_s *manager,
		const gchar *name, const gchar *type)
{
	return _election_make(manager, name, type, ELOP_RESYNC);
}

static GError *
_election_init(struct election_manager_s *manager, const gchar *name,
		const gchar *type)
{
	return _election_make(manager, name, type, ELOP_NONE);
}

static GError *
_election_start(struct election_manager_s *manager, const gchar *name,
		const gchar *type)
{
	return _election_make(manager, name, type, ELOP_START);
}

static GError *
_election_exit(struct election_manager_s *manager, const gchar *name,
		const gchar *type)
{
	return _election_make(manager, name, type, ELOP_EXIT);
}

static GError *
_election_has_peers(struct election_manager_s *manager,
		const gchar *name, const gchar *type, gboolean *peers_present)
{
	return sqlx_config_has_peers(manager->config, name, type, peers_present);
}

static GError *
_election_get_peers(struct election_manager_s *manager,
		const gchar *name, const gchar *type, gchar ***peers)
{
	return sqlx_config_get_peers(manager->config, name, type, peers);
}


static gboolean
wait_for_final_status(struct election_member_s *member,
		GTimeVal *pmax)
{
	GTimeVal tmp;

	while (!STATUS_FINAL(member->step)) {

		member_kickoff(member);

		g_get_current_time(&tmp);
		if (gtv_bigger(&tmp, pmax)) {
			GRID_WARN("TIMEOUT! (wait) [%s.%s]",
					member->name, member->type);
			return FALSE;
		}

		if (member_pending_for_too_long(member)) {
			GRID_WARN("TIMEOUT! (pending) [%s.%s]",
					member->name, member->type);
			return FALSE;
		}

		GRID_TRACE("Still waiting for a final status on [%s.%s]",
				member->name, member->type);

		g_time_val_add(&tmp, 1000000L);
		member_wait(member, &tmp);
	}

	return TRUE;
}

static enum election_status_e
_election_get_status(struct election_manager_s *m, const gchar *name,
		const gchar *type, gchar **master_url)
{
	GTimeVal max;
	int rc;
	gchar *url = NULL;
	struct election_member_s *member;

	MANAGER_CHECK(m);
	EXTRA_ASSERT(name != NULL);
	EXTRA_ASSERT(type != NULL);

	g_mutex_lock(m->lock);

	g_get_current_time(&max);
	g_time_val_add(&max, 1000000L * m->delay_max_wait);

	member = manager_init_member(m, name, type, TRUE);
	member_kickoff(member);

	if (!wait_for_final_status(member, &max)) // TIMEOUT!
		rc = STEP_FAILED;
	else {
		rc = member->step;
		if (rc == STEP_LOST) {
			if (member->master_url)
				url = g_strdup(member->master_url);
		}
	}

	member_unref(member);
	if (rc == STEP_NONE || STATUS_FINAL(rc))
		member_signal(member);
	member_unlock(member);

	GRID_TRACE("STEP=%s/%d master=%s", _step2str(rc), rc, url);
	switch (rc) {
		case STEP_LEADER:
			return ELECTION_LEADER;
		case STEP_LOST:
			if (master_url)
				*master_url = url;
			else
				g_free(url);
			url = NULL;
			return ELECTION_LOST;
		default:
			return ELECTION_FAILED;
	}
}

static void
_manager_clean(struct election_manager_s *manager)
{
	int i;

	if (!manager)
		return;

	if (manager->sync)
		manager->sync = NULL;

	if (manager->pool)
		manager->pool = NULL;

	if (manager->lrutree_members)
		lru_tree_destroy(manager->lrutree_members);

	if (manager->lock)
		g_mutex_free(manager->lock);

	for (i=0; i<COND_COUNT ;i++) {
		if (manager->conds[i])
			g_cond_free(manager->conds[i]);
	}

	memset(manager, 0, sizeof(*manager));
	g_free(manager);
}

const struct replication_config_s *
_manager_get_config(const struct election_manager_s *manager)
{
	return manager ? manager->config : NULL;
}

static GSList*
_get_to_be_notified(struct election_manager_s *manager, GTimeVal *pivot)
{
	GSList *res = NULL;

	gint _sort_by_status(gconstpointer p0, gconstpointer p1) {
		const GTimeVal *tv0, *tv1;

		tv0 = &(MEMBER(p0)->last_status);
		tv1 = &(MEMBER(p1)->last_status);
		return gtv_bigger(tv1, tv0) ? 1 : (gtv_bigger(tv0, tv1) ? -1 : 0);
	}

	gboolean _traverse(gpointer k, gpointer v, gpointer u) {
		struct election_member_s *m = v;
		(void) k;
		(void) u;
		switch (m->step) {
			case STEP_NONE:
				return FALSE;
			case STEP_CANDREQ:
			case STEP_CANDOK:
			case STEP_LEAVING:
			case STEP_PRELOST:
			case STEP_PRELEAD:
				if (!pivot || gtv_bigger(pivot, &(m->last_status)))
					res = g_slist_prepend(res, m);
			case STEP_LOST:
			case STEP_LEADER:
			case STEP_FAILED:
				return FALSE;
		}
		return FALSE;
	}

	lru_tree_foreach_TREE(manager->lrutree_members, _traverse, NULL);
	return g_slist_sort(res, _sort_by_status);
}

static guint
_manager_retry_elections(struct election_manager_s *manager,
		guint max, GTimeVal *end)
{
	guint count;
	GTimeVal now;
	GSList *l, *to_be_notified = NULL;

	MANAGER_CHECK(manager);
	if (manager->exiting)
		return 0;

	/* Generate the list of members to be notified */
	g_mutex_lock(manager->lock);
	g_get_current_time(&now);
	g_time_val_add(&now, SQLX_DELAY_ELECTION_REPLAY * -1000000L);
	to_be_notified = _get_to_be_notified(manager, &now);

	for (count=0,l=to_be_notified; l ;l=l->next) {
		struct election_member_s *m = l->data;
		g_get_current_time(&now);
		if (end && gtv_bigger(&now, end))
			break;
		if (max && count >= max)
			break;
		transition(m, EVT_NONE, NULL);
		count ++;
	}

	g_mutex_unlock(manager->lock);

	g_slist_free(to_be_notified);
	return count;
}

/* ------------------------------------------------------------------------- */

struct udata_USE_s
{
	guint reqid;
	struct election_member_s *member;
};

static void
on_end_USE(struct event_client_s *mc)
{
	struct udata_USE_s *udata;
	struct election_member_s *member;
	GError *err;

	EXTRA_ASSERT(mc != NULL);
	EXTRA_ASSERT(mc->client != NULL);
	EXTRA_ASSERT(mc->udata != NULL);
	udata = mc->udata;
	EXTRA_ASSERT(udata->member != NULL);
	member = udata->member;

	MEMBER_CHECK(member);
	err = gridd_client_error(mc->client);

	member_lock(member);
	transition(member, EVT_USE_RES, &(udata->reqid));
	member_unlock(member);

	if (err)
		g_error_free(err);
	g_free(udata);
}

static gboolean
defer_USE(struct election_member_s *member, time_t now)
{
	gboolean rc = FALSE;
	gchar **peers = NULL, **p = NULL;
	guint pending = 0;
	struct sqlx_name_s n;

	n.ns = "";
	n.base = member->name;
	n.type = member->type;

	GError *err = member_get_peers(member, &peers);
	if (err != NULL) {
		GRID_WARN("[%s] Election initiated (%s) but get_peers error: (%d) %s",
				__FUNCTION__, _step2str(member->step), err->code, err->message);
		g_clear_error(&err);
		rc = FALSE;
		goto end;
	}

	if (!peers || !*peers)
		pending = 0;
	else {
		if (member->pending_USE)
			pending = 0;
		else
			pending = g_strv_length(peers);
	}

	if (!pending) {
		member_trace(__FUNCTION__, "USE avoided", member);
		rc = TRUE; // FIXME: is it an error?
	} else {
		GByteArray *req;

		member->last_USE = now ? now : time(0);
		member->pending_USE = pending;
		member->reqid_USE = manager_next_reqid(member->manager);

		req = sqlx_pack_USE(&n);
		for (p=peers; p && *p ;p++) {
			struct udata_USE_s *udata;
			struct event_client_s *mc;

			member_ref(member);
			udata = g_malloc0(sizeof(*udata));
			udata->reqid = member->reqid_USE;
			udata->member = member;
			mc = g_malloc0(sizeof(*mc));
			mc->on_end = on_end_USE;
			mc->client = gridd_client_create(*p, req, NULL, NULL);
			gridd_client_set_timeout(mc->client,
					time2double(member->manager->delay_max_wait),
					time2double(member->manager->delay_max_wait));
			mc->udata = udata;
			gridd_client_pool_defer(member->manager->pool, mc);
		}
		g_byte_array_unref(req);

		member_trace(__FUNCTION__, "USE scheduled", member);
		rc = TRUE;
	}

end:
	if (peers)
		g_strfreev(peers);

	return rc;
}

/* ------------------------------------------------------------------------- */

static void
on_end_PIPEFROM(struct event_client_s *mc)
{
	GError *err;
	struct election_member_s *member;

	EXTRA_ASSERT(mc != NULL);
	EXTRA_ASSERT(mc->udata != NULL);
	member = mc->udata;
	EXTRA_ASSERT(member->manager != NULL);
	EXTRA_ASSERT(member->key != NULL);

	err = gridd_client_error(mc->client);
	GRID_DEBUG("PIPEFROM result [%s.%s] [%s]: (%d) %s",
			member->name, member->type,
			hashstr_str(member->key), err?err->code:0, err?err->message:"OK");

	member_lock(member);
	transition(member, EVT_RESYNC_DONE, &(member->reqid_PIPEFROM));
	member_unref(member);
	member_unlock(member);

	if (err)
		g_error_free(err);
}

static void
defer_PIPEFROM(struct election_member_s *member)
{
	MEMBER_CHECK(member);

	const gchar *source = member->master_url;
	const gchar *target = member_get_url(member);

	EXTRA_ASSERT(target != NULL);
	EXTRA_ASSERT(source != NULL);

	if (member->pending_PIPEFROM)
		member_debug(__FUNCTION__, "PIPEFROM avoided", member);
	else {
		struct event_client_s *mc;
		struct sqlx_name_s n;
		n.ns = "";
		n.base = member->name;
		n.type = member->type;

		member->reqid_PIPEFROM = manager_next_reqid(member->manager);
		member->requested_PIPEFROM = 0;
		member->pending_PIPEFROM = 1;

		GByteArray *req = sqlx_pack_PIPEFROM(&n, source);
		member_ref(member);
		mc = g_malloc0(sizeof(*mc));
		mc->client = gridd_client_create(target, req, NULL, NULL);
		gridd_client_set_timeout(mc->client, 30.0, 60.0);
		mc->on_end = on_end_PIPEFROM;
		mc->udata = member;
		g_byte_array_unref(req);

		gridd_client_pool_defer(member->manager->pool, mc);

		member_debug(__FUNCTION__, "PIPEFROM scheduled", member);
	}
}

/* ------------------------------------------------------------------------- */

struct udata_GETVERS_s
{
	guint reqid;
	struct election_member_s *member;
	GTree *version;
};

static void
on_end_GETVERS(struct event_client_s *mc)
{
	struct election_member_s *member;
	struct udata_GETVERS_s *udata;
	GError *err = NULL;
	GTree *vremote = NULL;
	GTree *vlocal = NULL;

	EXTRA_ASSERT(mc != NULL);
	EXTRA_ASSERT(mc->client != NULL);
	EXTRA_ASSERT(mc->udata != NULL);
	udata = mc->udata;
	EXTRA_ASSERT(udata->member != NULL);
	member = udata->member;
	MEMBER_CHECK(member);

	EXTRA_ASSERT(NULL != member->manager->config->get_version);

	err = gridd_client_error(mc->client);
	vremote = udata->version;
	udata->version = NULL;

	if (err)
		member_debug(err->message, "GETVERS result", member);

	if (!err && !vremote)
		err = NEWERROR(500, "BUG: no version received");

	if (!err)
		err = member->manager->config->get_version(
				member->manager->config->ctx,
				member->name, member->type, &vlocal);

	if (!err && !vlocal)
		err = NEWERROR(500, "BUG: no version loaded");

	if (!err) {
		gint64 worst = 0;
		err = version_validate_diff(vlocal, vremote, &worst);
		if (NULL != err) {
			if (err->code == CODE_PIPETO) {
				GRID_DEBUG("Remote outdated : (%d) %s",
						err->code, err->message);
				g_clear_error(&err);
			}
		} else {
			if (worst < 0)
				err = NEWERROR(CODE_PIPEFROM, "One diff missed");
		}
	}

	member_lock(member);
	if (!err)
		transition(member, EVT_GETVERS_OK, &(udata->reqid));
	else if (err->code == CODE_PIPEFROM)
		transition(member, EVT_GETVERS_OUTDATED, &(udata->reqid));
	else if (err->code == CODE_CONCURRENT)
		transition(member, EVT_GETVERS_CONCURRENT, &(udata->reqid));
	else {
		GRID_DEBUG("GETVERS error : (%d) %s", err->code, err->message);
		transition(member, EVT_GETVERS_ERROR, &(udata->reqid));
	}
	member_unlock(member);

	g_free(udata);

	if (err)
		g_clear_error(&err);
	if (vlocal)
		g_tree_destroy(vlocal);
	if (vremote)
		g_tree_destroy(vremote);
}

static gboolean
on_reply_GETVERS(gpointer ctx, struct message_s *reply)
{
	struct event_client_s *ec;
	struct udata_GETVERS_s *udata;
	void *b = NULL;
	gsize bsize = 0;

	GRID_TRACE2("%s(%p,%p)", __FUNCTION__, ctx, reply);
	EXTRA_ASSERT(reply != NULL);
	ec = ctx;
	EXTRA_ASSERT(ec != NULL);
	udata = ec->udata;
	EXTRA_ASSERT(udata != NULL);

	if (0 < message_get_BODY(reply, &b, &bsize, NULL)) {
		GTree *version;

		if (!(version = version_decode(b, bsize))) {
			GRID_WARN("Invalid encoded version in reply");
			return FALSE;
		}

		if (udata->version)
			g_tree_destroy(udata->version);
		udata->version = version;
	}

	return TRUE;
}

static void
defer_GETVERS(struct election_member_s *member)
{
	guint pending = 0;

	MEMBER_CHECK(member);
	GRID_TRACE2("%s(%p)", __FUNCTION__, member);

	gchar **peers = NULL;
	GError *err = member_get_peers(member, &peers);
	if (err != NULL) {
		GRID_WARN("[%s] Election initiated (%s) but get_peers error: (%d) %s",
				__FUNCTION__, _step2str(member->step), err->code, err->message);
		g_clear_error(&err);
		return;
	}

	pending = g_strv_length(peers);

	if (member->sent_GETVERS > 0)
		member_debug(__FUNCTION__ , "GETVERS req lost", member);

	struct sqlx_name_s n;
	n.ns = "";
	n.base = member->name;
	n.type = member->type;

	member->sent_GETVERS = pending;
	member->pending_GETVERS = pending;
	member->reqid_GETVERS = manager_next_reqid(member->manager);

	GByteArray *req = sqlx_pack_GETVERS(&n);
	for (gchar **p=peers; p && *p; p++) {
		struct event_client_s *mc;
		struct udata_GETVERS_s udata;

		member_ref(member);
		udata.reqid = member->reqid_GETVERS;
		udata.version = NULL;
		udata.member = member;
		mc = g_malloc0(sizeof(*mc));
		mc->on_end = on_end_GETVERS;
		mc->udata = g_memdup(&udata, sizeof(udata));
		mc->client = gridd_client_create(*p, req, mc, on_reply_GETVERS);
		gridd_client_set_timeout(mc->client,
				time2double(member->manager->delay_max_wait),
				time2double(member->manager->delay_max_wait));
		gridd_client_pool_defer(member->manager->pool, mc);
	}
	g_byte_array_unref(req);

	member_trace(__FUNCTION__ , "GETVERS scheduled", member);

	g_strfreev(peers);
}


/* ------------------------------------------------------------------------ */

static inline void
member_RESYNC_if_not_pending(struct election_member_s *member)
{
	if (!member->pending_PIPEFROM)
		member->requested_PIPEFROM = 1;
}

static void
become_leaver(struct election_member_s *member)
{
	member_reset_master(member);
	member_reset_pending(member);
	member_set_status(member, STEP_LEAVING);
	int zrc = step_LeaveElection_start(member);
	if (zrc != ZOK)
		member_set_status(member, STEP_FAILED);
}

static void
become_candidate(struct election_member_s *member)
{
	member_reset_master(member);
	member_set_status(member, STEP_CANDOK);
	if (ZOK != step_ListGroup_start(member))
		member_set_status(member, STEP_FAILED);
}

static void
manage_deleted(struct election_member_s *member)
{
	member_warn("DELETED", member);
	become_leaver(member);
}

static void
restart_election(struct election_member_s *member)
{
	int zrc;

	member_reset(member);
	if (member->manager->exiting) {
		member_set_status(member, STEP_NONE);
		return;
	}

	member->requested_USE = 0;

	member_set_status(member, STEP_CANDREQ);
	if (!defer_USE(member, 0)) {
		member_set_status(member, STEP_FAILED);
		return;
	}
	zrc = step_StartElection_start(member);
	if (ZOK != zrc) {
		member_warn_failed_creation(member, zrc);
		member_set_status(member, STEP_FAILED);
	}
}

static void
manage_list(struct election_member_s *member, GArray *i64v)
{
	int zrc;
	EXTRA_ASSERT(i64v != NULL);

	member_set_status(member, STEP_CANDOK);

	if (!member_in_group(member, i64v)) {
		member_trace(__FUNCTION__, "DISAPPEARED", member);
		restart_election(member);
	}
	else {
		if (member_group_master(member, i64v)) {
			member_set_master_id(member, member->myid);
			member_set_status(member, STEP_PRELEAD);
			defer_GETVERS(member);
		}
		else {
			member_set_master_id(member, g_array_index(i64v, gint64, 0));
			member_set_status(member, STEP_PRELOST);
			zrc = step_AskMaster_start(member);
			if (zrc != ZOK) {
				GRID_WARN("AskMaster failed [%s.%s] [%s] : (%d) %s",
						member->name, member->type, hashstr_str(member->key),
						zrc, zerror(zrc));
				become_leaver(member);
			}
			else {
				defer_GETVERS(member);
			}
		}
	}
}

static gboolean
member_concerned_by_GETVERS(struct election_member_s *member, guint *reqid)
{
	if (*reqid != member->reqid_GETVERS)
		return FALSE;
	if (member->pending_GETVERS > 0) {
		if (! -- member->pending_GETVERS)
			member->reqid_GETVERS = 0;
	}
	return TRUE;
}

static void
member_finish_PRELOST(struct election_member_s *member)
{
	if (member_has_action(member))
		return;

	int errors = member->errors_GETVERS;
	member->errors_GETVERS = 0;
	int concurrent = member->concurrent_GETVERS;
	member->concurrent_GETVERS = 0;

	// FIXME compare to the sizeof of the quorum
	if (errors > 1) {
		//become_candidate(member);
		member_reset(member);
		member_set_status(member, STEP_FAILED);
	} else if (concurrent > 1) {
		member_RESYNC_if_not_pending(member);
	} else {
		if (member->master_url)
			member_set_status(member, STEP_LOST);
	}
}

static void
member_finish_PRELEAD(struct election_member_s *member)
{
	if (member_has_action(member))
		return;

	int errors = member->errors_GETVERS;
	member->errors_GETVERS = 0;
	int concurrent = member->concurrent_GETVERS;
	member->concurrent_GETVERS = 0;

	// FIXME compare to the sizeof of the quorum
	if (errors > 1) {
		member_reset(member);
		member_set_status(member, STEP_FAILED);
	} else if (concurrent > 1) {
		// No quorum, so become a LOSER and resync from the master.
		become_leaver(member);
	} else {
		member_set_status(member, STEP_LEADER);
	}
}

static inline time_t
member_ping_delay(struct election_member_s *member)
{
	switch (member->step) {
		case STEP_CANDREQ:
		case STEP_CANDOK:
		case STEP_PRELOST:
		case STEP_PRELEAD:
			return MMANAGER(member)->delay_ping_pending;
		case STEP_FAILED:
			return MMANAGER(member)->delay_ping_failed;
		default:
			return MMANAGER(member)->delay_ping_final;
	}
}

static void
member_ping(struct election_member_s *member)
{
	time_t delay, now;

	now = time(0);
	delay = member_ping_delay(member);

	if (!member->last_USE || member->last_USE + delay < now
			|| member->last_USE > now)
		if (!defer_USE(member, now))
			become_leaver(member);
}

static void
_transition(struct election_member_s *member, enum event_type_e evt,
		void *evt_arg)
{
	gchar tag[256];
	guint reqid;
	int zrc;

	MEMBER_CHECK(member);
	g_snprintf(tag, sizeof(tag), "EVENT:%s", _evt2str(evt));
	member_debug(__FUNCTION__, tag, member);

	switch (evt) {

		case EVT_DISCONNECTED:
			member_reset(member);
			member_set_status(member, STEP_FAILED);
			return;

		case EVT_USE_RES:
			EXTRA_ASSERT(evt_arg != NULL);
			reqid = *((guint*)evt_arg);
			if (reqid == member->reqid_USE) {
				if (member->pending_USE > 0)
					-- member->pending_USE;
			}
			if (!member->pending_USE)
				member->reqid_USE = 0;
			break;

		case EVT_RESYNC_DONE:
			EXTRA_ASSERT(evt_arg != NULL);
			reqid = *((guint*)evt_arg);
			if (reqid == member->reqid_PIPEFROM) {
				member->pending_PIPEFROM = 0;
				member->reqid_PIPEFROM = 0;
			}
			break;

		default:
			break;
	}

	switch (member->step) {

		case STEP_NONE:
			if (evt == EVT_NONE || evt == EVT_RESYNC_REQ)
				restart_election(member);
			return;

		case STEP_CANDREQ:
			switch (evt) {
				case EVT_RESYNC_REQ:
					member_RESYNC_if_not_pending(member);
					return;
				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_CREATE_OK:
					EXTRA_ASSERT(evt_arg != NULL);
					member_set_id(member, *((gint64*)evt_arg));
					if (ZOK != step_WatchNode_start(member))
						member_set_status(member, STEP_FAILED);
					else
						become_candidate(member);
					return;
				case EVT_CREATE_KO:
					zrc = *((int*)evt_arg);
					member_warn_failed_creation(member, zrc);
					member_set_status(member, STEP_FAILED);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_CANDOK:
			switch (evt) {
				case EVT_NONE:
					member_ping(member);
					return;
				case EVT_RESYNC_REQ:
					member_RESYNC_if_not_pending(member);
					return;
				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_LIST_OK:
					manage_list(member, evt_arg);
					return;
				case EVT_LIST_KO:
				case EVT_NODE_LEFT:
					become_candidate(member);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_PRELOST:
			switch (evt) {
				case EVT_NONE:
					if (member_pending_for_too_long(member)) {
						// See TO-HONEYCOMB-757
						GRID_INFO("Election for [%s] seems stale, "
							"restarting GETVERS", member->name);
						defer_GETVERS(member);
					} else {
						member_ping(member);
					}
					return;
				case EVT_RESYNC_REQ:
					member_RESYNC_if_not_pending(member);
				case EVT_DISCONNECTED:
				case EVT_USE_RES:
					return;

				case EVT_CREATE_OK:
				case EVT_CREATE_KO:
				case EVT_LEAVE_OK:
				case EVT_LEAVE_KO:
				case EVT_LIST_OK:
				case EVT_LIST_KO:
					member_warn("ABNORMAL", member);
				case EVT_NODE_LEFT:
				case EVT_MASTER_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
					become_candidate(member);
					return;

				case EVT_EXITING:
					become_leaver(member);
					return;

				case EVT_MASTER_OK:
					EXTRA_ASSERT(evt_arg != NULL);
					member_set_master_url(member, (gchar*)evt_arg);
					member_finish_PRELOST(member);
					return;

				case EVT_GETVERS_OK:
					if (member_concerned_by_GETVERS(member, evt_arg))
						member_finish_PRELOST(member);
					return;

				case EVT_GETVERS_OUTDATED:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						member_RESYNC_if_not_pending(member);
						// No need to finish, the RESYNC itself is a
						// pending action avoiding the finish
					}
					return;

				case EVT_GETVERS_CONCURRENT:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						++ member->concurrent_GETVERS;
						member_finish_PRELOST(member);
					}
					return;

				case EVT_GETVERS_ERROR:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						++ member->errors_GETVERS;
						member_finish_PRELOST(member);
					}
					return;

				case EVT_RESYNC_DONE:
					if (!member_has_action(member) && member->master_url)
						member_set_status(member, STEP_LOST);
					return;
			}
			return;

		case STEP_PRELEAD:
			switch (evt) {
				case EVT_NONE:
					if (member_pending_for_too_long(member)) {
						// See TO-HONEYCOMB-757
						GRID_INFO("Election for [%s] seems stale, "
							"restarting GETVERS", member->name);
						defer_GETVERS(member);
					} else {
						member_ping(member);
					}
					return;
				case EVT_RESYNC_REQ:
				case EVT_EXITING:
					become_leaver(member);
				case EVT_DISCONNECTED:
				case EVT_USE_RES:
					return;
				case EVT_CREATE_OK:
				case EVT_CREATE_KO:
				case EVT_NODE_LEFT:
				case EVT_MASTER_OK:
				case EVT_MASTER_KO:
				case EVT_LIST_OK:
				case EVT_LIST_KO:
				case EVT_LEAVE_OK:
				case EVT_LEAVE_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
				case EVT_RESYNC_DONE:
					become_candidate(member);
					return;

				case EVT_GETVERS_OUTDATED:
					if (member_concerned_by_GETVERS(member, evt_arg))
						become_leaver(member);
					return;

				case EVT_GETVERS_OK:
					if (member_concerned_by_GETVERS(member, evt_arg))
						member_finish_PRELEAD(member);
					return;

				case EVT_GETVERS_CONCURRENT:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						++ member->concurrent_GETVERS;
						member_finish_PRELEAD(member);
					}
					return;

				case EVT_GETVERS_ERROR:
					if (member_concerned_by_GETVERS(member, evt_arg)) {
						++ member->errors_GETVERS;
						member_finish_PRELEAD(member);
					}
					return;
			}
			return;

		case STEP_LEAVING:
			switch (evt) {
				case EVT_NONE:
					if (!member->manager->exiting)
						member->requested_USE = 1;
					return;
				case EVT_RESYNC_REQ:
					member_RESYNC_if_not_pending(member);
					return;
				case EVT_LEAVE_OK:
					GRID_INFO("LEFT election [%s.%s]", member->name, member->type);
					member_reset(member);
					member_set_status(member, STEP_NONE);
					return;
				case EVT_LEAVE_KO:
					become_leaver(member);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_LOST:
			switch (evt) {
				case EVT_NONE:
					member_ping(member);
					return;
				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_NODE_LEFT:
					manage_deleted(member);
					return;
				case EVT_MASTER_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
					become_candidate(member);
					return;
				case EVT_RESYNC_REQ:
					member->requested_PIPEFROM = 1;
					member_set_status(member, STEP_PRELOST);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_LEADER:
			switch (evt) {
				case EVT_NONE:
					member_ping(member);
					return;
				case EVT_RESYNC_REQ:
				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_NODE_LEFT:
					manage_deleted(member);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_FAILED:
			switch (evt) {
				case EVT_NONE:
					if (member_failed_for_too_long(member))
						restart_election(member);
					else
						member_ping(member);
					return;
				case EVT_RESYNC_REQ:
					member_RESYNC_if_not_pending(member);
					restart_election(member);
					return;
				case EVT_CREATE_KO:
				case EVT_NODE_LEFT:
					member_reset(member);
					member_set_status(member, STEP_FAILED);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;
	}
}

static void
transition(struct election_member_s *member, enum event_type_e evt,
		void *evt_arg)
{
	enum election_step_e pre, post;

	pre = member->step;
	_transition(member, evt, evt_arg);
	post = member->step;

	if (evt != EVT_NONE || pre != post)
		member_log_event(member, pre, evt);

	if (member->requested_PIPEFROM && member->master_url)
		defer_PIPEFROM(member);

	if (member->requested_USE && (member->step == STEP_NONE))
		restart_election(member);
}

static void
transition_error(struct election_member_s *member,
		enum event_type_e evt, enum ZOO_ERRORS zrc)
{
	EXTRA_ASSERT(zrc <= ZSYSTEMERROR || zrc <= ZAPIERROR);

	if (zrc < ZAPIERROR)
		transition(member, evt, &zrc);
	else if (zrc < ZSYSTEMERROR)
		transition(member, EVT_DISCONNECTED, &zrc);
	else {
		g_assert_not_reached();
	}
}

static gboolean
_count_runner(hashstr_t *k, struct election_member_s *v,
		struct election_counts_s *count)
{
	(void) k;
	++ count->total;
	switch (v->step) {
		case STEP_NONE:
			++ count->none;
			return FALSE;
		case STEP_CANDREQ:
		case STEP_CANDOK:
		case STEP_LEAVING:
		case STEP_PRELOST:
		case STEP_PRELEAD:
			++ count->pending;
			return FALSE;
		case STEP_LOST:
			++ count->slave;
			return FALSE;
		case STEP_LEADER:
			++ count->master;
			return FALSE;
		case STEP_FAILED:
		default:
			++ count->failed;
			return FALSE;
	}
}

static struct election_counts_s
_manager_count(struct election_manager_s *manager)
{
	struct election_counts_s count;

	memset(&count, 0, sizeof(count));
	if (manager != NULL) {
		g_mutex_lock(manager->lock);
		lru_tree_foreach_DEQ(manager->lrutree_members,
				(GTraverseFunc) _count_runner, &count);
		g_mutex_unlock(manager->lock);
	}
	return count;
}

const gchar *
sqlx_config_get_local_url(const struct replication_config_s *cfg)
{
	if (!cfg || !cfg->get_local_url)
		return NULL;
	return cfg->get_local_url(cfg->ctx);
}

GError *
sqlx_config_get_peers(const struct replication_config_s *cfg, const gchar *n,
		const gchar *t, gchar ***result)
{
	if (!cfg || !cfg->get_peers) {
		if (result)
			*result = NULL;
		return NULL;
	}
	GError *err = cfg->get_peers(cfg->ctx, n, t, result);
	if (!err)
		return NULL;
	gchar msg[256];
	g_snprintf(msg, sizeof(msg), "get_peers(%s,%s): ", n, t);
	g_prefix_error(&err, msg);
	return err;
}

GError *
sqlx_config_has_peers(const struct replication_config_s *cfg, const gchar *n,
		const gchar *t, gboolean *result)
{
	gchar **peers = NULL;
	GError *err = sqlx_config_get_peers(cfg, n, t, &peers);
	if (err != NULL) {
		*result = FALSE;
		return err;
	}
	*result = peers != NULL && peers[0] != NULL;
	if (peers)
		g_strfreev(peers);
	return NULL;
}

