{{UNLESS module_name}}
#error "Invalid configuration, no module_name defined"
{{STOP}}
{{END}}
{{UNLESS module_functions}}
#error "Invalid configuration, no module_functions defined"
{{STOP}}
{{END}}

#include <meta2/module/internals.h>

/* ------------------------------------------------------------------------- */

struct {{module_name}}_autogenerated_stat_s {
	gint64 total;
	gint64 failures;
	{{FOREACH f IN module_functions}}gint64 {{f.name}};
	{{END}}
};

static struct {{module_name}}_autogenerated_stat_s counters;
static struct {{module_name}}_autogenerated_stat_s times;

{{BLOCK clean_variable-}}
	{{IF what.serializer}}{{SWITCH what.serializer}}
		{{CASE constants.SERIALIZE_STRUCT}}
		{{CASE constants.SERIALIZE_ARRAY}}
		{{CASE constants.SERIALIZE_INTEGER}}
		{{CASE constants.SERIALIZE_POINTER}}
			if ({{what.local_name}}) {
				g_free({{what.local_name}});
				{{what.local_name}} = NULL;
			}
		{{CASE constants.SERIALIZE_STRING}}
			if ({{what.local_name}}) {
				g_free({{what.local_name}});
				{{what.local_name}} = NULL;
			}
		{{CASE}}
			{{IF what.is_list}}
				{{IF what.singleton}}
					if ({{what.local_name}}) {
						{{what.cleaner}}({{what.local_name}},NULL);
						{{what.local_name}} = NULL;
					}
				{{ELSE}}
					if ({{what.local_name}}) {
						g_slist_foreach({{what.local_name}},{{what.cleaner}},NULL);
						g_slist_free({{what.local_name}});
						{{what.local_name}} = NULL;
					}
				{{END}}
			{{ELSE}}
				if ({{what.local_name}}) {
					{{what.cleaner}}({{what.local_name}},NULL);
					{{what.local_name}} = NULL;
				}
			{{END}}
		{{END}}
	{{END}}
{{-END}}

{{BLOCK clean_arg_variables}}
do {
	{{FOREACH arg IN function.args}}{{PROCESS clean_variable what = arg}}
	{{END}}
	{{PROCESS clean_variable what = function.return}}
} while (0);
{{END}}

{{BLOCK send_arg_to_reply}}
do {
	GByteArray *gba;

	/* Serialize */
	{{PROCESS serialize_data gba="gba" arg=what err="&(ctx.warning)"}}

	/* Set in the right location */
	{{SWITCH what.message_location}}
	{{CASE 'body'}}
		reply_context_set_body(&ctx, gba->data, gba->len, REPLYCTX_COPY|REPLYCTX_DESTROY_ON_CLEAN);
	{{CASE 'header'}}
		reply_context_add_header_in_reply(&ctx, "{{what.message_name}}", gba);
	{{END}}
	g_byte_array_free(gba,TRUE);
} while (0);
{{END}}

{{FOREACH f IN module_functions}}
static gint
handler_{{f.name}} (struct request_context_s *req_ctx, void *p)
{
	/*Declare the woking structures*/
	GTimer *timer;
	struct reply_context_s ctx;
	gchar str_access[1024];
	gsize str_access_size;
	{{f.return.type}} result;
	{{FOREACH arg IN f.args}}{{arg.type}} {{arg.local_name}};{{END}}

	/*Initialize all the variables according to their type*/
	(void)p;
	str_access_size = 0;
	memset(&ctx,0x00,sizeof(ctx));
	timer = g_timer_new();
	ctx.req_ctx = req_ctx;
	
	{{FOREACH arg IN f.args}}{{SWITCH arg.serializer}}
	{{CASE constants.SERIALIZE_STRUCT}}memset(&{{arg.local_name}},0x00,sizeof({{arg.local_name}}));
	{{CASE constants.SERIALIZE_ARRAY}}memset({{arg.local_name}},0x00,sizeof({{arg.local_name}}));
	{{CASE}}{{arg.local_name}} = 0;
	{{END}}{{END-}}
	
	{{IF f.return.serializer}}{{SWITCH f.return.serializer}}
	{{CASE constants.SERIALIZE_STRUCT}}memset(&{{f.return.local_name}},0x00,sizeof({{f.return.local_name}}));
	{{CASE constants.SERIALIZE_ARRAY}}memset({{f.return.local_name}},0x00,sizeof({{f.return.local_name}}));
	{{CASE}}{{f.return.local_name}} = NULL;
	{{END}}{{END-}}
	
	/*Unpack the request*/
	{{FOREACH arg IN f.in_args}}
		{{SWITCH arg.message_location}}
		{{CASE 'header'}}
			{{PROCESS get_arg_from_header where=arg.local_name err='&(ctx.warning)' msg='req_ctx->request' arg=arg}}
		{{CASE 'body'}}
			{{PROCESS get_arg_from_body where=arg.local_name err='&(ctx.warning)' msg='req_ctx->request' arg=arg}}
		{{CASE}}
			{{STOP}}
		{{END}}
		{{SWITCH arg.type}}
		{{CASE 'container_id_t'}}
			str_access_size = container_id_to_string({{arg.local_name}}, str_access+str_access_size,
					sizeof(str_access)-str_access_size);
		{{CASE}}
		{{END}}
	{{END}}

	/*Execute the back-end function*/
	result = {{f.prefix}}_{{f.real_name}}({{FOREACH arg IN f.args}}
			{{IF arg.is_out}}&{{END}}{{arg.local_name}},
			{{END}}&(ctx.warning));
	(void) result;

	/*Prepare the reply*/
	{{FOREACH arg IN f.out_args}}
	{{IF arg.on_error}}if (ctx.warning){{ELSE}}if (!ctx.warning){{END}} {
		{{IF arg.is_list && !arg.singleton}}
			GSList *l0, *l1;

			l0 = gslist_split({{arg.local_name}}, 32);
			for(l1=l0;l1;l1=l1->next) {
				GByteArray *gba;

				/* Un p'tit coup de nettoyage sur le message precedent */
				reply_context_set_message(&ctx, 206, "Partial content");

				/* Serialize */
				{{save = arg.local_name}}
				{{arg.local_name = "l1->data"}}
				{{PROCESS serialize_data gba="gba" arg=arg err="&(ctx.warning)"}}
				{{arg.local_name = save}}

				/* Set in the right location */
				{{SWITCH arg.message_location}}
				{{CASE 'body'}}
					reply_context_set_body(&ctx, gba->data, gba->len, REPLYCTX_COPY|REPLYCTX_DESTROY_ON_CLEAN);
				{{CASE 'header'}}
					reply_context_add_header_in_reply(&ctx, "{{what.message_name}}", gba);
				{{END}}
				g_byte_array_free(gba,TRUE);

				if (!reply_context_reply(&ctx,&(ctx.warning))) {
					GSETERROR(&(ctx.warning),"Operation successful but unable to reply to the client");
					goto error_label;
				}
				reply_context_clear(&ctx, FALSE);
			}
			gslist_chunks_destroy(l1, NULL);
		{{ELSE}}
			{{PROCESS send_arg_to_reply what=arg}}
		{{END}}
	}
	{{END}}
	{{IF f.return.serializer}}
		{{IF f.return.on_error}}if (ctx.warning){{ELSE}}if (!ctx.warning){{END}} {
			{{PROCESS send_arg_to_reply what=f.return}}
		}
	{{END}}

	if (ctx.warning) {
		GSETERROR(&(ctx.warning),"Back-end function [%s] failed", "{{f.prefix}}_{{f.name}}");
		goto error_label;
	}

	/* Fill an empty list in the body of the 200 OK */
	if (!ctx.warning) {
	{{-FOREACH arg IN f.out_args}}
	{{-IF not arg.on_error}}
	{{-IF arg.is_list && !arg.singleton}}
	{{-IF arg.message_location == 'body'}}
		do { /* XXX JFS fills the '200 OK' with an empty list to make old clients happy */
			GByteArray *gba;
			{{-save = arg.local_name}}
			{{-arg.local_name = "NULL"}}
			{{-PROCESS serialize_data gba="gba" arg=arg err="NULL"}}
			{{-arg.local_name = save}}
			if (gba) {
				reply_context_set_body(&ctx, gba->data, gba->len, REPLYCTX_COPY|REPLYCTX_DESTROY_ON_CLEAN);
				g_byte_array_free(gba, TRUE);
			}
		} while (0);
	{{-END}}{{END}}{{END}}{{END}}
	}

	/*Forward the reply*/
	reply_context_set_message(&ctx, 200, "OK");
	if (!reply_context_reply(&ctx,&(ctx.warning))) {
		GSETERROR(&(ctx.warning),"Operation successful but unable to reply to the client");
		goto error_label;
	}
	reply_context_log_access(&ctx,"%.*s", str_access_size, str_access);
	STOP_TIMER(timer,__FUNCTION__);

	/*Clean the working structures*/
	{{PROCESS clean_arg_variables function=f}}
	reply_context_clear (&ctx, TRUE);
	g_timer_destroy(timer);
	return 1;

error_label:
	reply_context_set_message(&ctx, gerror_get_code(ctx.warning), gerror_get_message(ctx.warning));
	if (!reply_context_reply(&ctx,NULL))
		GSETERROR(&(ctx.warning),"In addition, failed to reply to the client");
	ERROR("Operation '{{f.name}}' failed : %s", gerror_get_message(ctx.warning));
	reply_context_log_access(&ctx,"coming soon");
	STOP_TIMER(timer,__FUNCTION__);

        LOCK_STATS();
	counters.failures ++;
	UNLOCK_STATS();

	/*Clean the working structures*/
	{{PROCESS clean_arg_variables function=f}}
	g_timer_destroy(timer);
	reply_context_clear (&ctx, TRUE);
	return 0;
}
{{END}}

/* ------------------------------------------------------------------------- */

void
meta2_autogenerated_update_stats(gpointer d)
{
	gdouble val;
	struct {{module_name}}_autogenerated_stat_s workingStats, workingTimes;

	(void)d;
	LOCK_STATS();
	memcpy (&workingStats,  &counters,  sizeof(struct {{module_name}}_autogenerated_stat_s));
	memcpy (&workingTimes,  &times,     sizeof(struct {{module_name}}_autogenerated_stat_s));
	UNLOCK_STATS();

	val = workingStats.total;
	srvstat_set ("{{module_name}}.req_counter.total", val);
	
	{{ FOREACH f IN module_functions }}
	val = workingStats.{{f.name}};
	srvstat_set ("{{module_name}}.req_counter.{{f.name}}", val);
	
	val = workingTimes.{{f.name}};
	srvstat_set ("{{module_name}}.req_time.{{f.name}}", val);
	{{END}}
}

static struct cmd_s CMD_autogenerated[] =
{
	{{FOREACH f IN module_functions}}
	{"{{f.request_name}}",
		handler_{{f.name}}, NULL,
		&(counters.{{f.name}}), &(times.{{f.name}}),
		{{f.flags}}},
	{{END}}
	{NULL,NULL,NULL,NULL,NULL, 0}
};

struct cmd_s *meta2_CMD_autogenerated = CMD_autogenerated;

