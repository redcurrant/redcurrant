/**
 * @file metautils_internals.h
 * features internal to metautils.
 */

#ifndef __METAUTILS_INTERNALS_H__
# define __METAUTILS_INTERNALS_H__
# include <stdarg.h>
# include <stdlib.h>
# include <unistd.h>
# include "metatypes.h"
# include "metautils.h"
# include "metacomm.h"

/**
 * @param in
 * @param out
 * @return
 */
typedef gboolean(*abstract_converter_f) (const void *in, void *out);

/**
 * @param asn
 * @param only_content
 */
typedef void (*abstract_asn_cleaner_f) (void *asn, gboolean only_content);

/**
 * @param api
 */
typedef void (*abstract_api_cleaner_f) (void *api);

/**
 *
 */
struct abstract_sequence_handler_s
{
	size_t asn1_size;                     /**< sizeof() on the ASN structure */
	size_t api_size;                      /**< sizeof() on the API structure */
	void *asn1_descriptor;                /**< pointer to the descriptor generated by asn1c */
	abstract_converter_f map_ASN1_to_API; /**< conversion from API to ASN */
	abstract_converter_f map_API_to_ASN1; /**< conversion from ASN to API */
	abstract_asn_cleaner_f clean_ASN1;    /**< structure cleaner */
	abstract_api_cleaner_f clean_API;     /**< structure cleaner */
	const gchar const *type_name;         /**< Type name used in error messages */
};

/**
 * @param h
 * @param list
 * @param asn1_encoded
 * @param asn1_encoded_size
 * @param err
 * @return
 */
gssize abstract_sequence_unmarshall(const struct abstract_sequence_handler_s *h,
    GSList ** list, const void *asn1_encoded, gsize asn1_encoded_size,
	GError ** err);

/**
 * @param h
 * @param api_sequence
 * @param err
 * @return
 */
GByteArray *abstract_sequence_marshall(const struct abstract_sequence_handler_s *h,
    GSList * api_sequence, GError ** err);

/**
 * @param cnx
 * @param error
 * @param h
 * @param req
 * @param body
 * @param args
 * @return
 */
GSList *abstract_sequence_request(struct metacnx_ctx_s *cnx, GError ** error,
    const struct abstract_sequence_handler_s *h, const gchar * req,
	GByteArray * body, va_list args);

#define DEFINE_BODY_MANAGER(Name,Unmarshall) \
gint Name (GError **err, gpointer udata, gint code, guint8 *body, gsize bodySize) {\
	GSList **resL, *list;\
	resL = (GSList**) udata; (void)code;\
	if (!udata || !body || !bodySize) {\
		GSETERROR(err,"Invalid parameter (%p %p %u)", udata, body, bodySize);\
		return FALSE;\
	}\
	list=NULL;\
	if (0 >= Unmarshall (&list, body, &bodySize, err)) {\
		GSETERROR (err, "Cannot unserialize the content of the reply");\
		return FALSE;\
	}\
	*resL = g_slist_concat (*resL,list);\
	return TRUE;\
}

#define DEFINE_SEQUENCE_MARSHALLER_GBA(Descr,Name) \
GByteArray* Name (GSList *list, GError **err) {\
	GByteArray *gba = abstract_sequence_marshall(Descr, list, err);\
	if (!gba) {\
		GSETERROR(err,"Serialization error");\
		return 0;\
	}\
	return gba;\
}

#define DEFINE_SEQUENCE_MARSHALLER(Descr,Name) \
gint Name (GSList *list, void **dst, gsize *dstSize, GError **err) {\
	if (!dst || !dstSize) {\
		GSETERROR(err,"Invalid parameter");\
		return 0;\
	}\
	GByteArray *gba = abstract_sequence_marshall(Descr, list, err);\
	if (gba) {\
		*dstSize = gba->len;\
		*dst = gba->data;\
		g_byte_array_free( gba, FALSE );\
		return 1;\
	}\
	GSETERROR(err,"Marshalling error");\
	return 0;\
}

#define DEFINE_SEQUENCE_UNMARSHALLER(Descr,Name) \
gint Name (GSList **list, const void *source, gsize *sourceSize, GError **err) {\
	gssize consumed;\
	if (!list || !source || !sourceSize) {\
		GSETERROR(err,"Invalid parameter (list=%p src=%p/%"G_GSIZE_FORMAT")", list, source, (sourceSize?*sourceSize:0));\
		return -1;\
	}\
	consumed = abstract_sequence_unmarshall(Descr, list, source, *sourceSize, err );\
	if (consumed>0) {\
		*sourceSize = consumed;\
		return 1;\
	}\
	return 0;\
}

#define DEFINE_MARSHALLER_GBA(Name) DEFINE_SEQUENCE_MARSHALLER_GBA(&seq_descriptor, Name)

#define DEFINE_MARSHALLER(Name) DEFINE_SEQUENCE_MARSHALLER(&seq_descriptor, Name)

#define DEFINE_UNMARSHALLER(Name) DEFINE_SEQUENCE_UNMARSHALLER(&seq_descriptor, Name)

#define ASN_DEBUG(fmt,...) TRACE_DOMAIN("asn1c",fmt,##__VA_ARGS__)

#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) { \
		int c = '*'; size_t n; size_t max = max_size; /*tmp var to avoid a warning*/\
		for ( n = 0; n < max && \
			(c = getc( yyin )) != EOF && c != '\n'; ++n ) \
		buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
	} else { \
		size_t max = max_size; /*tmp var to avoid a warning*/\
		errno=0; \
		while ( (result = fread(buf, 1, max, yyin))==0 && ferror(yyin)) { \
			if( errno != EINTR) { \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
			} \
			errno=0; \
			clearerr(yyin); \
		} \
	}\

#define ERRNO_RESETBYPEER 104
#define ERRNO_NOTCONNECTED 107
#define ERRNO_CONNREFUSED 111
#define ERRNO_NOROUTETOHOST 113

static inline gint
errno_to_errcode(int e)
{
	switch (e) {
	case ERRNO_RESETBYPEER:
		return ERRCODE_CONN_RESET;
	case ERRNO_CONNREFUSED:
		return ERRCODE_CONN_REFUSED;
	case ERRNO_NOROUTETOHOST:
		return ERRCODE_CONN_TIMEOUT;
	case ERRNO_NOTCONNECTED:
		return ERRCODE_CONN_NOTCONNECTED;
	}
	return 0;
}

#endif /*__METAUTILS_INTERNALS_H__*/
